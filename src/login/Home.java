/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package login;

import Connection.DBConnection;
import Support.CodeOperations;
import com.sun.jmx.snmp.BerDecoder;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;
import net.sf.jasperreports.engine.JRException;
import net.sf.jasperreports.engine.JasperCompileManager;
import net.sf.jasperreports.engine.JasperFillManager;
import net.sf.jasperreports.engine.JasperPrint;
import net.sf.jasperreports.engine.JasperReport;
import net.sf.jasperreports.engine.design.JasperDesign;
import net.sf.jasperreports.engine.xml.JRXmlLoader;
import net.sf.jasperreports.view.JasperViewer;


/**
 *
 * @author Prabath
 */
public class Home extends javax.swing.JFrame {

    int evtX;
    int evtY;
    int x;
    int y;
    boolean login = false;
    //Removing Duplicates
    private ArrayList<String> functionList;
    private ArrayList<Integer> levels = new ArrayList<>();
    //to retrieve the level
    private LevelRetriever levelRetriever = new LevelRetriever();
    //object from CodeOperations class
    CodeOperations co = new CodeOperations();
    private ArrayList<String> methodNames;
    private ArrayList<String> functions;
    private ArrayList<String> functionNames;
    private ArrayList<String> recursiveFunctions;
    
    String newId = null;
    
    Connection con = DBConnection.getConnection();
    ResultSet rs = null;
    PreparedStatement ps = null;

    /**
     * Creates new form Home
     */
    public Home() {
        initComponents();
        methodNames = new ArrayList<>();
        functionNames = new ArrayList<>();
        functions = new ArrayList<>();
        recursiveFunctions = new ArrayList<>();
        
        fillReportId();
    }

    private void fillReportId() {
        
        //query to get last entered Event_ID
        String latests_sql = "SELECT MAX(id) AS Total FROM codecp";
        
        try {
            ps = con.prepareStatement(latests_sql);
            rs = ps.executeQuery();

            if (rs.next()) {
                //retrieve Event_ID
                newId = rs.getString("Total");
            }
            System.out.println(newId);

        } catch (SQLException ex) {
            Logger.getLogger(History.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jLabel4 = new javax.swing.JLabel();
        jLabel11 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        sCode = new javax.swing.JTextArea();
        jComboBox1 = new javax.swing.JComboBox<String>();
        jLabel2 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        codeTable = new javax.swing.JTable();
        jLabel15 = new javax.swing.JLabel();
        jLabel16 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jTextField1 = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        infoIcon = new javax.swing.JLabel();
        jLabel12 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setUndecorated(true);
        getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jPanel1.setBackground(new java.awt.Color(255, 255, 255));
        jPanel1.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                jPanel1MouseDragged(evt);
            }
        });
        jPanel1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                jPanel1MousePressed(evt);
            }
        });
        jPanel1.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jLabel4.setFont(new java.awt.Font("Segoe UI", 0, 18)); // NOI18N
        jLabel4.setForeground(new java.awt.Color(255, 255, 255));
        jLabel4.setText("Welcome Shali");
        jPanel1.add(jLabel4, new org.netbeans.lib.awtextra.AbsoluteConstraints(1270, 50, -1, -1));

        jLabel11.setFont(new java.awt.Font("Segoe UI", 1, 12)); // NOI18N
        jLabel11.setForeground(new java.awt.Color(255, 255, 255));
        jLabel11.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/Shutdown_32px.png"))); // NOI18N
        jLabel11.setText("Log Out");
        jLabel11.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        jLabel11.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel11MouseClicked(evt);
            }
        });
        jPanel1.add(jLabel11, new org.netbeans.lib.awtextra.AbsoluteConstraints(1430, 50, 80, -1));

        jLabel3.setFont(new java.awt.Font("Segoe UI", 0, 16)); // NOI18N
        jLabel3.setForeground(new java.awt.Color(83, 109, 254));
        jLabel3.setText("Your result");
        jPanel1.add(jLabel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(640, 120, -1, -1));

        jLabel1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/Group 33.png"))); // NOI18N
        jPanel1.add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(-10, 30, 1550, 80));

        sCode.setColumns(20);
        sCode.setFont(new java.awt.Font("Segoe UI", 0, 16)); // NOI18N
        sCode.setForeground(new java.awt.Color(157, 157, 157));
        sCode.setRows(5);
        sCode.setText("Past Your Code Here...");
        jScrollPane1.setViewportView(sCode);

        jPanel1.add(jScrollPane1, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 150, 580, 700));

        jComboBox1.setFont(new java.awt.Font("Segoe UI", 0, 12)); // NOI18N
        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "C++", "JAVA" }));
        jPanel1.add(jComboBox1, new org.netbeans.lib.awtextra.AbsoluteConstraints(40, 880, 240, 40));

        jLabel2.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/Group 34.png"))); // NOI18N
        jLabel2.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        jLabel2.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel2MouseClicked(evt);
            }
        });
        jPanel1.add(jLabel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(520, 880, 65, 40));

        jLabel5.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/Group 31.png"))); // NOI18N
        jLabel5.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        jLabel5.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel5MouseClicked(evt);
            }
        });
        jPanel1.add(jLabel5, new org.netbeans.lib.awtextra.AbsoluteConstraints(1420, 890, 87, 47));

        codeTable.setFont(new java.awt.Font("Segoe UI", 1, 14)); // NOI18N
        codeTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Line", "Statement", "Identified Operators", "Cs", "Ctc", "Cnc", "Ci", "Tw", "Cps", "Cr"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false, false, false, false, true
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        codeTable.setRowHeight(20);
        jScrollPane2.setViewportView(codeTable);
        if (codeTable.getColumnModel().getColumnCount() > 0) {
            codeTable.getColumnModel().getColumn(0).setMaxWidth(40);
            codeTable.getColumnModel().getColumn(3).setPreferredWidth(35);
            codeTable.getColumnModel().getColumn(3).setMaxWidth(30);
            codeTable.getColumnModel().getColumn(4).setPreferredWidth(35);
            codeTable.getColumnModel().getColumn(4).setMaxWidth(35);
            codeTable.getColumnModel().getColumn(5).setPreferredWidth(35);
            codeTable.getColumnModel().getColumn(5).setMaxWidth(30);
            codeTable.getColumnModel().getColumn(6).setPreferredWidth(35);
            codeTable.getColumnModel().getColumn(6).setMaxWidth(30);
            codeTable.getColumnModel().getColumn(7).setPreferredWidth(35);
            codeTable.getColumnModel().getColumn(7).setMaxWidth(35);
            codeTable.getColumnModel().getColumn(8).setPreferredWidth(35);
            codeTable.getColumnModel().getColumn(8).setMaxWidth(30);
            codeTable.getColumnModel().getColumn(9).setPreferredWidth(35);
            codeTable.getColumnModel().getColumn(9).setMaxWidth(30);
        }

        jPanel1.add(jScrollPane2, new org.netbeans.lib.awtextra.AbsoluteConstraints(640, 150, 880, 670));

        jLabel15.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/Minus_20px.png"))); // NOI18N
        jLabel15.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel15MouseClicked(evt);
            }
        });
        jPanel1.add(jLabel15, new org.netbeans.lib.awtextra.AbsoluteConstraints(1480, 0, 20, 20));

        jLabel16.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/Delete_20px.png"))); // NOI18N
        jLabel16.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel16MouseClicked(evt);
            }
        });
        jPanel1.add(jLabel16, new org.netbeans.lib.awtextra.AbsoluteConstraints(1510, 0, 20, 20));

        jLabel6.setFont(new java.awt.Font("Segoe UI", 1, 24)); // NOI18N
        jLabel6.setText("0");
        jPanel1.add(jLabel6, new org.netbeans.lib.awtextra.AbsoluteConstraints(690, 840, 100, -1));

        jLabel7.setFont(new java.awt.Font("Segoe UI", 0, 16)); // NOI18N
        jLabel7.setForeground(new java.awt.Color(83, 109, 254));
        jLabel7.setText("Save as : ");
        jPanel1.add(jLabel7, new org.netbeans.lib.awtextra.AbsoluteConstraints(1230, 840, -1, -1));

        jTextField1.setForeground(new java.awt.Color(157, 157, 157));
        jTextField1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(83, 109, 254)));
        jPanel1.add(jTextField1, new org.netbeans.lib.awtextra.AbsoluteConstraints(1300, 840, 210, 30));

        jLabel8.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/Group 1_1.png"))); // NOI18N
        jLabel8.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        jLabel8.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel8MouseClicked(evt);
            }
        });
        jPanel1.add(jLabel8, new org.netbeans.lib.awtextra.AbsoluteConstraints(410, 880, 92, 47));

        jLabel9.setFont(new java.awt.Font("Segoe UI", 0, 24)); // NOI18N
        jLabel9.setText("Cp : ");
        jPanel1.add(jLabel9, new org.netbeans.lib.awtextra.AbsoluteConstraints(640, 840, -1, -1));

        jLabel10.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/Group 7_1.png"))); // NOI18N
        jLabel10.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        jLabel10.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel10MouseClicked(evt);
            }
        });
        jPanel1.add(jLabel10, new org.netbeans.lib.awtextra.AbsoluteConstraints(1220, 890, 86, 48));

        infoIcon.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/Info_20px.png"))); // NOI18N
        infoIcon.setToolTipText("More Info.");
        infoIcon.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                infoIconMouseClicked(evt);
            }
        });
        jPanel1.add(infoIcon, new org.netbeans.lib.awtextra.AbsoluteConstraints(730, 120, 20, 20));

        jLabel12.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/Group 3.png"))); // NOI18N
        jLabel12.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        jLabel12.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabel12MouseClicked(evt);
            }
        });
        jPanel1.add(jLabel12, new org.netbeans.lib.awtextra.AbsoluteConstraints(1320, 890, 86, 48));

        getContentPane().add(jPanel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, 1540, 960));

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jPanel1MousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jPanel1MousePressed
        evtX = evt.getX();
        evtY = evt.getY();
    }//GEN-LAST:event_jPanel1MousePressed

    private void jPanel1MouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jPanel1MouseDragged
        x = evt.getXOnScreen();
        y = evt.getYOnScreen();

        this.setLocation(x - evtX, y - evtY);
    }//GEN-LAST:event_jPanel1MouseDragged

    private void jLabel2MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel2MouseClicked
        sCode.setText("");
    }//GEN-LAST:event_jLabel2MouseClicked

    private void jLabel15MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel15MouseClicked
        this.setState(1);
    }//GEN-LAST:event_jLabel15MouseClicked

    private void jLabel16MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel16MouseClicked
        System.exit(0);
    }//GEN-LAST:event_jLabel16MouseClicked

    private void jLabel10MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel10MouseClicked
        History history = new History();
        history.setVisible(true);
        history.pack();
        history.setLocationRelativeTo(null);
        this.dispose();
    }//GEN-LAST:event_jLabel10MouseClicked

    private void infoIconMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_infoIconMouseClicked
        Info info = new Info();
        info.setVisible(true);
        info.pack();
        info.setLocationRelativeTo(null);
    }//GEN-LAST:event_infoIconMouseClicked

    private void jLabel11MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel11MouseClicked
        Login login = new Login();
        login.setVisible(true);
        login.pack();
        login.setLocationRelativeTo(null);
        this.dispose();
    }//GEN-LAST:event_jLabel11MouseClicked

    private void jLabel12MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel12MouseClicked

        //check whether fields are empty
        if (sCode.getText().equals("") || jTextField1.getText().equals("")) {
            //show error message
            JOptionPane.showMessageDialog(null, "Please Verify All Fields..!");
        } else {
            //get code name
            String name = jTextField1.getText();

            //get language of the code 
            String language = jComboBox1.getSelectedItem().toString();

            //get current date
            String date = new SimpleDateFormat("dd-MM-yyyy").format(new Date());

            //get code from Textarea
            String code = sCode.getText();

            //get cp value
            int cp = Integer.parseInt(jLabel6.getText());

            //insert details to DB 
            co.insert(name, date, language, code, cp);
        }
    }//GEN-LAST:event_jLabel12MouseClicked

    private void jLabel8MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel8MouseClicked
        // TODO add your handling code here:
        nestedComplexity(sCode.getText());
        tableGenrator(sCode.getText());
    }//GEN-LAST:event_jLabel8MouseClicked

    private void jLabel5MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabel5MouseClicked
        
        try {
            //load the jasper file by giving the location
            JasperDesign jd = JRXmlLoader.load("D:/Users/Kasun/Documents/NetBeansProjects/Complexity_Report/complexity.jrxml");
            
            //initialize parameters
            HashMap parameters = new HashMap();
            parameters.put("ID", newId);
            
            //compile jasper file and fill report using given values
            JasperReport jr = JasperCompileManager.compileReport(jd);
            JasperPrint jp = JasperFillManager.fillReport(jr, parameters, con);
            JasperViewer jv = new JasperViewer(jp, false); //create new jasper viewer
            jv.setVisible(true);
            
        } catch (JRException ex) {
            Logger.getLogger(History.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_jLabel5MouseClicked

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Home.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Home.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Home.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Home.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Home().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTable codeTable;
    private javax.swing.JLabel infoIcon;
    private javax.swing.JComboBox<String> jComboBox1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JTextArea sCode;
    // End of variables declaration//GEN-END:variables

    public void nestedComplexity(String sC) {
        //take the source code from here
        String sourceCode = sC;

        levels.clear();

        ArrayList<String> classes = classGenarator(sourceCode);
        //class by class
        for (String clas : classes) {
//            System.out.println(clas);
            levelRetriever = new LevelRetriever();
            //get function list here
            ArrayList<String> functions = functionGenerator(clas);
            //total counter
            int total = 0;

            //check are there any function available
            if (!functions.isEmpty()) {
                //to get string of a function
                LevelRetriever functionInside = new LevelRetriever();

                //position
                int i = 0;

                //iterate function by function
                for (String function : functions) {
                    //get the position where function starts
                    i = skipUnWanted(function, 0) + 1;
                    //Use to append the String inside function paranthesis
                    String insideAppender = "";
                    functionInside.insertFirst(i, '{');

                    for (; i < function.length(); i++) {
                        char position = function.charAt(i);
                        //appending the strings inside the function function
                        insideAppender = insideAppender + position;

                        //parenthesis check for get all string inside the function scope
                        if (position == '{') {
                            functionInside.insertFirst(i, position);
                        } else if (position == '}') {
                            try {
                                functionInside.deleteFirst();
                                if (functionInside.isEmpty()) {
//                                    int functionComplexity = analysWithStack(insideAppender);
                                    //System.out.println(insideAppender + "\nfunction Complexity : " + functionComplexity+ "\n-------------------");
//                                    total = total + functionComplexity;
                                }
                            } catch (NullPointerException e) {
                                e.printStackTrace();
                            }
                        }
                    }

                }

                //System.out.println("Check total : " + total);
            } else {
                //System.out.println(analysWithStack(sourceCode));
                total = analysWithStack(sourceCode);
            }

    //        //analyse code with stack
            //        int total = splitAnalyzer(sourceCode);
    //        analyzedValue.setText(total + "");
            //        JOptionPane.showMessageDialog(this, "Nested Comlexity : " + total);    
            //        LineShower lineShower = new LineShower();
            //        lineShower.takeNestedLevels(levels);
            //        lineShower.tableGenrator(sourceCode);
            //        lineShower.setVisible(true);
        }

    }

    public int analysWithStack(String sourceCode) throws StringIndexOutOfBoundsException {

        boolean forIfIndicator = false;
        //to catch else statements
        LevelRetriever elseCatcher = new LevelRetriever();
        boolean checkForElse = false;
        String elseAppender = "";
        //end elseCatcher statements

        //Creating new instance of code Refactor
        CodeRefactor codeRefactor = new CodeRefactor();

        sourceCode = codeRefactor.tryCatchOmitter(sourceCode);
        sourceCode = codeRefactor.bracketInsideOmmitter(sourceCode);
//        System.out.println(sourceCode);

        //System.out.println("\n================\n" + codeRefactor.tryCatchOmitter(sourceCode) + "\n==============\n");
        //level indicator
        int level = 0;
        //total indicator
        int total = 0;

        for (int i = 0; i < sourceCode.length(); i++) {
            //get the character
            char position = sourceCode.charAt(i);
//            System.out.println("Levels" + levels);
            if (checkForElse) {
                elseCatcher.insertFirst(level, position);
            }

            //single if for
            String forIfCheck = forIfChecker(sourceCode, i);
            if (forIfCheck.contains("for") || forIfCheck.contains("if")) {
                forIfIndicator = true;
            }

            if (forIfIndicator) {
                if (position == ')' && sourceCode.charAt(i + 1) != '{' && sourceCode.charAt(i + 1) != ';') {
                    //checking for single if and for
                    if (forIfChecker(sourceCode, i + 1).trim().isEmpty()) {
                        //to check else if
                        String elseIfChecker = "";
                        for (int j = (i - 20); j < i; j++) {
                            elseIfChecker += sourceCode.charAt(j);
                        }

                        if (!elseIfChecker.contains("else")) {
                            if (levelRetriever.isEmpty()) {
                                level = +1;
                                levelRetriever.insertFirst(level, '}');
                                total = total + level;
                                levels.add(level);
                                levelRetriever.deleteFirst();
                                //                            System.out.println("level Empty : " + level);
                                level -= 1;
                            } else {
                                //if there are some inside the stack
                                //get first
                                Link first = levelRetriever.getFirst();
                                //get the stack value
                                level = first.increment + 1;
                                total = total + level;
                                levels.add(level);
                                //                            System.out.println("level : " + level);
                            }
                        }
                        forIfIndicator = false;
                    }
                }
            }

            if (position == '{') {
                //should increment the level by one
                //check whether stack is empty
                if (levelRetriever.isEmpty()) {

                    //loop untile else catcher gets empty
                    while (!elseCatcher.isEmpty()) {
                        Link getCharacter = elseCatcher.deleteFirst();
                        elseAppender = elseAppender + getCharacter.value;
                    }

                    //inserting into the stack
                    //if empty level = 1 
                    level = +1;
                    levelRetriever.insertFirst(level, position);

                    //if else keyword found
                    if (!elseAppender.contains("esle")) {
                        //count total
                        total = total + level;
                        levels.add(level);
//                        levelIndicator.setLineWrap(true);
//                        levelIndicator.setText(levelIndicator.getText() + level + " ");
//                        System.out.println("Level isempty else not cont, total added " + level);
                    } else {

                        //check for else now should equal to false
                        checkForElse = false;
                        //and else appender should equal to empty String
                        elseAppender = "";
//                        System.out.println("Level isempty else cont, total not added " + level);        
                    }
                } else {
                    //loop untile else catcher gets empty
                    while (!elseCatcher.isEmpty()) {
                        Link getCharacter = elseCatcher.deleteFirst();
                        elseAppender = elseAppender + getCharacter.value;
                    }

                    //if there are some inside the stack
                    //get first
                    Link first = levelRetriever.getFirst();
                    //get the stack value
                    level = first.increment + 1;

                    if (!elseAppender.contains("esle")) {
                        //and insert new level
                        levelRetriever.insertFirst(level, position);
                        total = total + level;
                        levels.add(level);
//                        levelIndicator.setLineWrap(true);
//                        levelIndicator.setText(levelIndicator.getText() + level + " ");

//                        System.out.println("Level else not cont, total added " + level);
                    } else {
                        //without adding to the total just inserting
                        levelRetriever.insertFirst(level, position);
                        //checkFor else no need until next } found
                        checkForElse = false;
                        //and else appender should equal to empty String
                        elseAppender = "";
//                        System.out.println("Level else cont, total not added " + level);

                    }

                }
            } else if (position == '}') {
                //checkForFalse should start appending String now
                checkForElse = true;
                //clear all elseAppender
                elseAppender = "";
                //clear all inside the stack
                while (!elseCatcher.isEmpty()) {
                    elseCatcher.deleteFirst();
                }
                //checks parenthesis match
                if (levelRetriever.isEmpty()) {
                    //if not there is something wrong
                    System.err.println("Code has Errors!");
                    break;
                } else {
                    //now delete first from the stack
                    Link deletedFirst = levelRetriever.deleteFirst();
                    //level should decrease by one
                    level = deletedFirst.increment - 1;
//                    System.out.println(level);
                }
            }
        }

//        System.out.println("Total : " + total);
        return total;

    }

    private static Pattern ptn
            = Pattern.compile("[a-zA-Z][a-zA-Z0-9]+\\(");

    public static List<String> captureValues(String largeText) {
        Matcher mtch = ptn.matcher(largeText);
        List<String> ips = new ArrayList<String>();
        while (mtch.find()) {
            ips.add(mtch.group());
        }
        return ips;
    }

    // Function to remove duplicates from an ArrayList 
    public ArrayList<String> removeDuplicates(ArrayList<String> list) {

        // Create a new ArrayList 
        ArrayList<String> newList = new ArrayList<String>();

        // Traverse through the first list 
        for (String element : list) {

            // If this element is not present in newList 
            // then add it 
            if (!newList.contains(element)) {

                newList.add(element);
            }
        }

        // return the new list 
        return newList;
    }

    public ArrayList<String> classGenarator(String sourceCode) {

        //Creating new instance of code Refactor
        CodeRefactor codeRefactor = new CodeRefactor();

        //ommitting Strings inside String literals
        sourceCode = codeRefactor.stringOmmitter(sourceCode);

        //ommitting single line and multi line comments
        //regex expression is used to ommit multiline and single line
        sourceCode = codeRefactor.commentOmmitter(sourceCode);
        //to get rid of '{' and '}'
        sourceCode = codeRefactor.singleQuotesOmmitter(sourceCode);

        ArrayList<String> classes = new ArrayList<>();
        String classAppender = "";
        LevelRetriever classScope = new LevelRetriever();

        for (int i = 0; i < sourceCode.length(); i++) {
            char position = sourceCode.charAt(i);
            classAppender += position;

            if (position == '{') {
                classScope.insertFirst(i, position);
            } else if (position == '}') {
                classScope.deleteFirst();
                if (classScope.isEmpty()) {
                    classes.add(classAppender);
                    classAppender = "";
                }
            }

        }

        return classes;
    }

    public ArrayList<String> functionGenerator(String sourceCode) {

        //capturing all words that includes (
        List<String> functionWithGarbage = captureValues(sourceCode);

        List<String> functionListWithDuplicates = new ArrayList<>();

        for (String f : functionWithGarbage) {
            //System.out.println(f);
            if (!f.equals("if(") && !f.equals("for(") && !f.equals("while(") && !f.equals("if(")) {
                functionListWithDuplicates.add(f);
            }
        }

        //Removing Duplicates
        this.functionList = removeDuplicates((ArrayList<String>) functionListWithDuplicates);

        //to get individualy each function
        ArrayList<String> functions = new ArrayList<>();

        //if there are function names
        if (!functionList.isEmpty()) {
            //Level Retriever for get function scope
            LevelRetriever scope = new LevelRetriever();

            //function appender
            String functionAppender = "";

            //starting point
            int i = 0;
            //boolean value for check main and classes
            boolean checker = true;

            //for loop looping through the function
            for (; i < sourceCode.length(); i++) {
                //used to skip the main function and classes
                //becuase all recursions we can find inside a class or main
                String check = functionChecker(sourceCode, i);
                //|| check.contains("main")
                if (check.contains("class")) {
                    checker = false;
                }

                if (checker) {
                    char posision = sourceCode.charAt(i);

                    functionAppender = functionAppender + posision;

                    if (posision == '{') {
                        scope.insertFirst(i, posision);
                    } else if (posision == '}') {
                        try {
                            scope.deleteFirst();
                            if (scope.isEmpty()) {
                                functions.add(functionAppender.trim());
                                functionAppender = "";
                            }
                        } catch (NullPointerException e) {
//                            e.printStackTrace();
                        }
                    }

                } else {
                    i = skipUnWanted(sourceCode, i);
                    checker = true;
                }

            }

//            for(String f : functions){
//                System.out.println(f + "\n----------------------------------");
//            }
        }
        return functions;
    }

    private int skipUnWanted(String sourceCode, int i) {

        while (sourceCode.charAt(i) != '{') {
            i++;
        }

        return i;
    }

    public String forIfChecker(String sourceCode, int i) {
        String appender = "";
        if ((i + 3) > sourceCode.length()) {
            for (int j = i; j < sourceCode.length(); j++) {
                char pos = sourceCode.charAt(j);
                appender = appender + pos;
            }
        } else {
            for (int j = i; j < i + 3; j++) {
                char pos = sourceCode.charAt(j);
                appender = appender + pos;
            }
        }

        return appender;
    }

    public String functionChecker(String sourceCode, int i) {
        String appender = "";
        if ((i + 25) > sourceCode.length()) {
            for (int j = i; j < sourceCode.length(); j++) {
                char pos = sourceCode.charAt(j);
                appender = appender + pos;
            }
        } else {
            for (int j = i; j < i + 25; j++) {
                char pos = sourceCode.charAt(j);
                appender = appender + pos;
            }
        }

        return appender;
    }

    private static Pattern ptnFunc
            = Pattern.compile("(public|protected|private|static|\\s) +[\\w\\<\\>\\[\\]]+\\s+(\\w+) *\\([^\\)]*\\) *(\\{?|[^;])");

    public static ArrayList<String> captureFunctions(String largeText) {
        Matcher mtch = ptnFunc.matcher(largeText);
        ArrayList<String> ips = new ArrayList<String>();
        while (mtch.find()) {
            ips.add(mtch.group());
        }
        return ips;
    }

    private Pattern methodNamePtn
            = Pattern.compile("[a-zA-Z][a-zA-Z0-9]+\\(");

    public String captureMethodsNames(String largeText) {
        Matcher mtch = methodNamePtn.matcher(largeText);
        String ips = "";
        while (mtch.find()) {
            ips = mtch.group();
        }
        return ips;
    }

    public void tableGenrator(String sourceCode) {
        DefaultTableModel model = (DefaultTableModel) codeTable.getModel();
        String identifiedOperator = "";
        LevelRetriever recursiveScope = new LevelRetriever();
        String cnc = "0";
        String cr = "";
        int i = 0;
        int levelIncrementor = 0;
        int cp = 0;

        LevelRetriever scopeOfNestedLevel = new LevelRetriever();
        boolean getScope = false;
        boolean recursive = false;
        String recursiveFunction = "";
        String functionName = "";

        String appender = "";
        for (int line = 0; line < sourceCode.length(); line++) {
            char position = sourceCode.charAt(line);
            appender = appender + position;

//            if (getScope) {
//                if (position == '{') {
//                    scopeOfNestedLevel.insertFirst(line, position);
//                } else if (position == '}') {
//                    if (!scopeOfNestedLevel.isEmpty()) {
//                        scopeOfNestedLevel.deleteFirst();
//                        cnc = Integer.toString(Integer.parseInt(cnc) - 1);
//                        if(Integer.parseInt(cnc) < 0){
//                            cnc = "0";
//                        }
//                        
//                    } else if (scopeOfNestedLevel.isEmpty()) {
//                        getScope = false;
//                    }
//                }
//            }
            
            if(position == '{' && recursive){
                recursiveScope.insertFirst(i, position);
            }else if(position == '}' && recursive){
                recursiveScope.deleteFirst();
            }
            
            if(!recursiveScope.isEmpty() && recursive){
                cr = "cp*2";
                if(position == '}'){
                    cr = "0";
                }
            }else{
                cr = "0";
                recursive = false;
            }

            if (appender.contains("\n")) {
                i++;
//                if (nestedCheck(appender)) {
//                    try {
//                        if (levelIncrementor != (levels.size() - 1)) {
//                            cnc = Integer.toString(levels.get(levelIncrementor++));
//                        }
//                        getScope = true;
//                        identifiedOperator = indicator(appender) + ", ";
//                        scopeOfNestedLevel.insertFirst(line, position);
//
//                    } catch (IndexOutOfBoundsException exe) {
//
//                    }
//                }
                
                //recursive functions
                if(isFunction(appender)){
                    functionName = getFunction(appender);
                    if(recursiveIndicator(functionName)){
                        recursive = true;
                        recursiveFunction = functionName;
                        recursiveScope.insertFirst(i, position);
                    }
                }
                String tempCnc = cnc;
                if(appender.contains("}\n") || appender.contains("//") || appender.contains("try{\n") || appender.contains("else if") || appender.contains("}else{")||appender.contains("}while(")){
                    cnc = "0";
                    cr = "0";
                }else if(appender.contains("\n") && !appender.contains(";\n")&& !appender.contains("); \n") && !appender.contains(")\n") && !appender.contains("{\n")&&!nestedCheck(appender)){
                    cnc = "0";
                    cr="0";
                }
                if(appender.contains(recursiveFunction)&&recursive){
                    identifiedOperator+=recursiveFunction+", ";
                }
                
                //get ctc value for each line
                int ctc = Ctc(appender);
                
                CS1 getCs1 = new CS1(appender);
                int cs1 = getCs1.getCs();
                
                CS2 getCs2 = new CS2(appender);
                int cs2 = getCs2.getCs();
                
                int cs = cs1 + cs2;
                
                Inheritence getInheritence = new Inheritence(appender);
                int ci = getInheritence.getInheritence();
                
                int tw = ctc + Integer.parseInt(cnc) + ci;  //get TW value
                int cps = cs * tw;  //get Cps value
                
                cp = cp + cps;
                if(cr.equals("cp*2")){
                    int x = cps * 2;
                    cr = Integer.toString(x);
                }
                jLabel6.setText(String.valueOf(cp));
                
                identifiedOperator+=CtcIndicator(appender);
                
                model.addRow(new Object[]{i, appender, identifiedOperator, cs, ctc, cnc, ci, tw, cps, cr});
                System.out.println(appender + " " + appender.contains("\n") + " "+scopeOfNestedLevel.isEmpty() + " "+ getScope);
                if (getScope && scopeOfNestedLevel.isEmpty()) {
                    cnc = "0";
                }
                
                appender = "";
                identifiedOperator = "";
            } else if ((sourceCode.length() - 1) == line) {
                i++;
                model.addRow(new Object[]{i, appender, "", "", "", "", "", "", "", ""});
                cnc = "";
                identifiedOperator = "";
            }

        }
    }

    boolean isFunction(String text){
        Matcher m = ptnFunc.matcher(text);
//        System.out.println(m.find());
        return m.find();
    }



    private String getFunction(String appender) {
        String function = captureMethodsNames(appender);
        String clear = "";
        for(int i = 0; i < function.length();i++){
            char position = function.charAt(i);
            if(position=='('){
                break;
            }
            
            clear+=position;
        }
//        System.out.println(clear);
        return clear;
    }



    public boolean recursiveIndicator(String functionName){
//        System.out.println("f name : " + functionName);
        ArrayList<String> classes = classGenarator(sCode.getText());
        String theFunction = "";
        //class by class
        for (String clas : classes) {
            ArrayList<String> functions = functionGenerator(clas);
            
            for(String function : functions){
                String checkName = "";
                int j = 0;
                //in order to get the function name contains given functionName
                while(function.charAt(j) != '{'){
                    checkName+=function.charAt(j);
                    j++;
                }
                if(checkName.contains(functionName)){
                    theFunction = function;
                    break;
                }
            }

        }
        
        if(theFunction.length()>0){
            int startPoint = skipUnWanted(theFunction, 0);
            String appenderBody = "";
            for(int i = startPoint; i < theFunction.length(); i++){
                char position = theFunction.charAt(i);
                appenderBody += position;
            }
            
            if(appenderBody.contains(functionName)){
//                System.out.println( functionName + " true");
//                System.out.println("=======================");
                return true;
            }
        }
        
//        System.out.println(functionName + " false");
//        System.out.println("=======================");
        return false;
    }
    
    public String indicator(String appender) {
        String cncAppender = "";
        CodeRefactor codeRefactor = new CodeRefactor();

        String nestedCode = appender.trim();
        nestedCode = codeRefactor.bracketInsideOmmitter(nestedCode);
        nestedCode = codeRefactor.commentOmmitter(nestedCode);
        nestedCode = codeRefactor.singleQuotesOmmitter(nestedCode);
        nestedCode = codeRefactor.stringOmmitter(nestedCode);

        for (int i = 0; i < nestedCode.length(); i++) {
            char posC = nestedCode.charAt(i);

            if (nestedCode.contains("for")) {
                if (posC == '(') {
                    break;
                }

                cncAppender += posC;
            } else if (nestedCode.contains("if")) {
                if (posC == '(') {
                    break;
                }

                cncAppender += posC;
            } else if (nestedCode.contains("while")) {
                if (posC == '(') {
                    break;
                }

                cncAppender += posC;
            } else if (nestedCode.contains("do")) {
                if (posC == '{') {
                    break;
                }

                cncAppender += posC;
            } else if (nestedCode.contains("switch")) {
                if (posC == '(') {
                    break;
                }

                cncAppender += posC;
            }

        }

        return cncAppender.trim();
    }

    public boolean nestedCheck(String appender) {
        boolean success = false;
        CodeRefactor codeRefactor = new CodeRefactor();

        String nestedCode = appender;
        nestedCode = codeRefactor.bracketInsideOmmitter(nestedCode);
        nestedCode = codeRefactor.commentOmmitter(nestedCode);
        nestedCode = codeRefactor.singleQuotesOmmitter(nestedCode);
        nestedCode = codeRefactor.stringOmmitter(nestedCode);

        if ((nestedCode.contains("for") && (nestedCode.contains("for(") || nestedCode.contains("for "))) || (nestedCode.contains("if") && !nestedCode.contains("else if") && (nestedCode.contains("if(") || nestedCode.contains("if "))) || (nestedCode.contains("while") && !nestedCode.contains("}while") && (nestedCode.contains("while(") || nestedCode.contains("while ")))
                || (nestedCode.contains("do") && (nestedCode.contains("do{") || nestedCode.contains("do "))) || (nestedCode.contains("switch") && (nestedCode.contains("switch(") || nestedCode.contains("switch ")))) {

            success = true;

        }

        return success;
    }
    
    public String CtcIndicator(String append){
        String indicator = "";  //variable for store indicator types found
        
        //get content inside brackets using a stack
        InsideBrackets brackets = new InsideBrackets(append);
        String get = brackets.getRound();
            
        //read content inside brackets one by one
        for (int j = 0; j < get.length() - 1; j++) {

            //read & operator
            if (get.charAt(j) == '&' && get.charAt(j+1) != '&') 
                indicator += "&, ";
            //read | operator
            if (get.charAt(j) == '|' && get.charAt(j+1) != '|')
                indicator += "|, ";
            //read && operator    
            if (get.charAt(j) == '&' && get.charAt(j+1) == '&') {
                indicator += "&&, ";
                j++; //skip 2nd char identifies as one &
            }
            //read || operator
            if (get.charAt(j) == '|' && get.charAt(j+1) == '|') {
                indicator += "||, ";
                j++;
            }

        }
        //read case keyword
        if (append.contains("case"))
            indicator += "case, ";
        
        return indicator; //return indicators
        
    }

    public void recursiveFunctions(String code) {
        functionGenerator(code);

        this.methodNames = (ArrayList<String>) captureFunctions(code);

        for (String functionName : methodNames) {
            System.out.println(functionName);
        }

        for (String function : functions) {
            String appender = "";
            int i = 0;
            while (function.charAt(i) != '{') {
                appender = appender + function.charAt(i);
                i++;
            }

            functionNames.add(captureMethodsNames(appender));
        }

        System.out.println("=======================");
        for (String functionName : functionNames) {
            System.out.println(functionName);
        }

        for (String function : functions) {
            int i = 0;
            i = skipUnWanted(function, i);
            String appender = "";
            for (; i < function.length(); i++) {
                appender += function.charAt(i);
            }

            for (String functionName : functionNames) {
                if (appender.contains(functionName)) {
                    recursiveFunctions.add(functionName);
                }
            }

        }

        System.out.println("=======================");
        for (String recursiveFunction : recursiveFunctions) {
            System.out.println(recursiveFunction);
        }
    }

    public boolean setLogin(boolean login){
        this.login = login;
        return this.login;
    }
    
    public int Ctc(String sourceCode){
        
        String allCode = sourceCode; //get code from text field
        int count = 0; //variable to store complexity value
        
        /*
        . - any character except new line
        * - any number of characters
        ? - matches using lowest number of characters
        (.|\n) - any character including new lines
        */
        allCode = allCode.replaceAll("\".*\"", ""); //remove double quotes
        allCode = allCode.replaceAll("\\'.*?\\'", ""); //remove single quotes
        allCode = allCode.replaceAll("//.*?\n", ""); //remove single line comments
        String code = allCode.replaceAll("/\\*(.|\n)*?\\*/", ""); //remove multi-line comments
        
//        System.out.println(code);
        
        //count if conditions, logical and bitwise operators
        CountConditions getIf = new CountConditions(code, "if", 1);
        count = count + getIf.getCount();
        
        //count while
        CountConditions getWhile = new CountConditions(code, "while", 2);
        count = count + getWhile.getCount();
        
        //count for
        CountConditions getFor = new CountConditions(code, "for", 2);
        count = count + getFor.getCountForCatch();
        
        //count catch
        CountConditions getCatch = new CountConditions(code, "catch", 1);
        count = count + getCatch.getCountForCatch();   

        //count case blocks
        Pattern pSwitch = Pattern.compile("case ");
        Matcher mSwitch = pSwitch.matcher(code);
                
        while (mSwitch.find()) {
            ++count; //increment count
        }
 
        return count;
    }
}
